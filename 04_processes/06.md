## Стартиране на дъщерен процес

```
#include<sys/types.h>
#include<unistd.h>
pid_t fork(void);
pid_t getpid(void);
pid_t getppid(void);
```

- Успешно извикване на **fork()** създава нов процес, идентичен почти във всички аспекти с извикващия го процес.
- Родителският процес получава идентификатора (**pid**) на дъщерния процес, а дъщерния процес получава нула.
- При грешка и дъщерния процес не е създаден, **fork()** връща -1 и грешката (**errno**) може да бъде:

| Грешка | Пояснение                                                                                         |
| ------ | ------------------------------------------------------------------------------------------------- |
| EAGAIN | Ядрото не успя да разпредели определени ресурси, като например нов идентификатор (pid) на процес. |
| ENOMEM | Няма достатъчно памет на ядрото за изпълнение на заявката.                                        |

Програмен фрагмен за стартиране на дъщерен процес:
```
pid_t pid = fork();
if(pid > 0)
{
	printPIDs("PARENT");
	wait(&child_status);
}
else if(!pid) {
	printPIDs("CHILD");
	exit(0);
}
else if(pid == -1) 
	printf("ERROR");
	return EXIT_FAILURE;
}
```

Повече информация:
[Linux Programming](https://www.slideshare.net/EmertxeSlides/linux-programming-36666547)
