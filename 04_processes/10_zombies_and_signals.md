## Зомбита и проста обработка на сигнали

Когато дъщерен процес умре преди родителският процес, ядрото го поставя в специално състояние наречено зомби (**zombie**). Процесът в това състояние чака родителски процес да се допита до неговия статус и едва след това дъщерният процес престава да съществува като зомби. Ако родителският процес никога не запита за състоянието на дъщерният процес, тогава зомбито се превръща в призрак (**ghost**), което е много лоша практика. Ако родителският процес завърши преди дъщерните му процеси, то техен родител става началният процес. Началният процес, от своя страна, периодично изчаква всички свои дъщерни процеси, като по този начин гарантира, че никое от тях няма да остане зомби.

Изчакване на процес:
```c
#include<sys/wait.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);
```

Обработка на сигнали:
```c
#include<signal.h>
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
struct sigaction {
  void (*sa_handler)(int);
  void (*sa_sigaction)(int, siginfo_t *, void *);
  sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};
```

Какво се случва обаче, ако родителският процес умре преди дъщерният процес или ако той умре, преди да има възможност да изчака своите зомбита? Всеки път, когато даден процес се прекратява, ядрото на Линукс преглежда списъка на дъщерните процеси и ги възпроизвежда на началният процес (идентификатор на процеса pid = 1). Това гарантира, че никой процес няма да остане без родител. Началният процес, от своя страна, периодично изчаква всички свои дъщерни процеси, като по този начин гарантира, че никое от тях няма да остане зомби за твърде дълго време. Въпреки че това все още се счита за добра практика, тази предпазна мярка означава, че краткотрайните процеси не трябва да се притесняват прекомерно да чакат всичките си деца.