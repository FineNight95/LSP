## Четене на съдържанието на файл

Библиотеката **unistd.h** съдържа методи за работа с файлове:

```
#include<unistd.h>
ssize_t read(int fd, void *buf, size_t len);
```

- Всяко извикване чете **len** на брой байтове в **buf** от текущата позиция на файла, посочен в файловия дескриптор **fd**.
- При успех се връща броят байтове записание в **buf**.
- При грешка в резултат се връща -1, а информация за грешката се записва във **errno**.

Всъщност метода за четене може да доведе до много възможности:
- Връща стойност, равна на **len** и всички прочетени байтове са запазени в **buf**. Резултатите са както е предвидено.
- Връща стойност по-малка от len, но по-голяма от нула. Четените байтове се съхраняват в **buf**. Това може да се случи, защото сигналът прекъсва четенето в средата, в средата на четенето е възникнала грешка, повече от нула, но е налице по-малко от стойността на байтовете с леки байтове или EOF е достигнато, преди да бъдат прочетени байтове. Преиздаването на прочетеното (с съответно актуализираните стойности **buf** и **len**) ще прочете останалите байтове в останалата част от буфера или ще посочи причината за проблема.
- Връща стойност 0. Това показва **EOF**. Няма какво да чете.
- Извикването на метода блокира, тъй като няма налични данни. Това няма да се случи в режим на блокиране.
- Връща стойност -1 и грешката е зададена на **EINTR**. Това показва, че е получен сигнал преди четенето на байтове.
- Връща стойност -1, а грешката е зададена на **EAGAIN**. Това показва, че четенето би блокирало, защото понастоящем няма налични данни. Това се случва само в режим на блокиране.
- Връща стойност -1, а грешката е зададена на стойност, различна от **EINTR** или **EAGAIN**. Това показва по-сериозна грешка.
